diff -rupN monit-5.2.5_orig//config.h monit-5.2.5//config.h
--- monit-5.2.5_orig//config.h	1970-01-01 01:00:00.000000000 +0100
+++ monit-5.2.5//config.h	2011-06-02 17:33:51.958577298 +0200
@@ -0,0 +1,483 @@
+/* config.h.  Generated from config.h.in by configure.  */
+/* config.h.in.  Generated from configure.ac by autoheader.  */
+
+/* Define if building universal (internal helper macro) */
+/* #undef AC_APPLE_UNIVERSAL_BUILD */
+
+/* Define to 1 if using `getloadavg.c'. */
+#define C_GETLOADAVG 1
+
+/* Define to 1 if you have the <alloca.h> header file. */
+#define HAVE_ALLOCA_H 1
+
+/* Define to 1 if you have the <arpa/inet.h> header file. */
+#define HAVE_ARPA_INET_H 1
+
+/* Define to 1 if you have the <asm/page.h> header file. */
+/* #undef HAVE_ASM_PAGE_H */
+
+/* Define to 1 if you have the <asm/param.h> header file. */
+#define HAVE_ASM_PARAM_H 1
+
+/* Define to 1 if you have the `backtrace' function. */
+/* #undef HAVE_BACKTRACE */
+
+/* Define to 1 if you have the <cf.h> header file. */
+/* #undef HAVE_CF_H */
+
+/* Define to 1 if CPU wait information is available. */
+#define HAVE_CPU_WAIT 1
+
+/* Define to 1 if you have the <crt_externs.h> header file. */
+/* #undef HAVE_CRT_EXTERNS_H */
+
+/* Define to 1 if you have the <crypt.h> header file. */
+#define HAVE_CRYPT_H 1
+
+/* Define to 1 if you have the <ctype.h> header file. */
+#define HAVE_CTYPE_H 1
+
+/* Define to 1 if you have the <dirent.h> header file. */
+#define HAVE_DIRENT_H 1
+
+/* Define to 1 if you have the <errno.h> header file. */
+#define HAVE_ERRNO_H 1
+
+/* Define to 1 if you have the <execinfo.h> header file. */
+/* #undef HAVE_EXECINFO_H */
+
+/* Define to 1 if you have the <fcntl.h> header file. */
+#define HAVE_FCNTL_H 1
+
+/* Define to 1 if you have the `fork' function. */
+#define HAVE_FORK 1
+
+/* Define to 1 if you have the `getaddrinfo' function. */
+#define HAVE_GETADDRINFO 1
+
+/* Define to 1 if you have the <getopt.h> header file. */
+#define HAVE_GETOPT_H 1
+
+/* Define to 1 if you have the <glob.h> header file. */
+#define HAVE_GLOB_H 1
+
+/* Define to 1 if you have the <grp.h> header file. */
+#define HAVE_GRP_H 1
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define to 1 if you have the <kstat.h> header file. */
+/* #undef HAVE_KSTAT_H */
+
+/* Define to 1 if you have the <kvm.h> header file. */
+/* #undef HAVE_KVM_H */
+
+/* Define to 1 if you have the `crypt' library (-lcrypt). */
+#define HAVE_LIBCRYPT 1
+
+/* Define to 1 if you have the `inet' library (-linet). */
+/* #undef HAVE_LIBINET */
+
+/* Define to 1 if you have the `nsl' library (-lnsl). */
+#define HAVE_LIBNSL 1
+
+/* Define to 1 if you have the `pam' library (-lpam). */
+/* #undef HAVE_LIBPAM */
+
+/* Define to 1 if you have the <libperfstat.h> header file. */
+/* #undef HAVE_LIBPERFSTAT_H */
+
+/* Define to 1 if you have the `resolv' library (-lresolv). */
+#define HAVE_LIBRESOLV 1
+
+/* Define to 1 if you have the `socket' library (-lsocket). */
+/* #undef HAVE_LIBSOCKET */
+
+/* Define to 1 if you have the <limits.h> header file. */
+#define HAVE_LIMITS_H 1
+
+/* Define to 1 if you have the <loadavg.h> header file. */
+/* #undef HAVE_LOADAVG_H */
+
+/* Define to 1 if you have the <locale.h> header file. */
+#define HAVE_LOCALE_H 1
+
+/* Define to 1 if you have the `localtime_r' function. */
+#define HAVE_LOCALTIME_R 1
+
+/* Define to 1 if you have the <machine/pmap.h> header file. */
+/* #undef HAVE_MACHINE_PMAP_H */
+
+/* Define to 1 if you have the <machine/vmparam.h> header file. */
+/* #undef HAVE_MACHINE_VMPARAM_H */
+
+/* Define to 1 if you have the <mach/host_info.h> header file. */
+/* #undef HAVE_MACH_HOST_INFO_H */
+
+/* Define to 1 if you have the <mach/mach.h> header file. */
+/* #undef HAVE_MACH_MACH_H */
+
+/* Define to 1 if you have the <mach/mach_host.h> header file. */
+/* #undef HAVE_MACH_MACH_HOST_H */
+
+/* Define to 1 if your system has a GNU libc compatible `malloc' function, and
+   to 0 otherwise. */
+#define HAVE_MALLOC 1
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the <mntent.h> header file. */
+#define HAVE_MNTENT_H 1
+
+/* Define to 1 if you have /etc/mnttab */
+/* #undef HAVE_MNTTAB */
+
+/* Define to 1 if you have /etc/mtab */
+#define HAVE_MTAB 1
+
+/* Define to 1 if you have the <netdb.h> header file. */
+#define HAVE_NETDB_H 1
+
+/* Define to 1 if you have the <netinet/in.h> header file. */
+#define HAVE_NETINET_IN_H 1
+
+/* Define to 1 if you have the <netinet/in_systm.h> header file. */
+#define HAVE_NETINET_IN_SYSTM_H 1
+
+/* Define to 1 if you have the <netinet/ip.h> header file. */
+#define HAVE_NETINET_IP_H 1
+
+/* Define to 1 if you have the <netinet/ip_icmp.h> header file. */
+#define HAVE_NETINET_IP_ICMP_H 1
+
+/* Define to 1 if you have the <net/if.h> header file. */
+#define HAVE_NET_IF_H 1
+
+/* Define to 1 if you have openssl. */
+/* #undef HAVE_OPENSSL */
+
+/* Define to 1 if you have the <pam/pam_appl.h> header file. */
+/* #undef HAVE_PAM_PAM_APPL_H */
+
+/* Define to 1 if you have the <paths.h> header file. */
+#define HAVE_PATHS_H 1
+
+/* Define to 1 if you have the <poll.h> header file. */
+#define HAVE_POLL_H 1
+
+/* Define to 1 if you have the <procfs.h> header file. */
+/* #undef HAVE_PROCFS_H */
+
+/* Define to 1 if you have the <procinfo.h> header file. */
+/* #undef HAVE_PROCINFO_H */
+
+/* Define to 1 if you have the <pthread.h> header file. */
+#define HAVE_PTHREAD_H 1
+
+/* Define to 1 if you have the <pwd.h> header file. */
+#define HAVE_PWD_H 1
+
+/* Define to 1 if you have the <regex.h> header file. */
+#define HAVE_REGEX_H 1
+
+/* Define to 1 if you have the <security/pam_appl.h> header file. */
+/* #undef HAVE_SECURITY_PAM_APPL_H */
+
+/* Define to 1 if you have the <setjmp.h> header file. */
+#define HAVE_SETJMP_H 1
+
+/* Define to 1 if you have the `setlocale' function. */
+#define HAVE_SETLOCALE 1
+
+/* Define to 1 if you have the <signal.h> header file. */
+#define HAVE_SIGNAL_H 1
+
+/* Define to 1 if SOL_IP is defined. */
+#define HAVE_SOL_IP 1
+
+/* Define to 1 if you have the `statfs' function. */
+#define HAVE_STATFS 1
+
+/* Define to 1 if you have the `statvfs' function. */
+#define HAVE_STATVFS 1
+
+/* Define to 1 if `stat' has the bug that it succeeds when given the
+   zero-length file name argument. */
+#define HAVE_STAT_EMPTY_STRING_BUG 1
+
+/* Define to 1 if you have the <stdarg.h> header file. */
+#define HAVE_STDARG_H 1
+
+/* Define to 1 if you have the <stddef.h> header file. */
+#define HAVE_STDDEF_H 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdio.h> header file. */
+#define HAVE_STDIO_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the `strftime' function. */
+#define HAVE_STRFTIME 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the <stropts.h> header file. */
+/* #undef HAVE_STROPTS_H */
+
+/* Define to 1 if `tm_gmtoff' is a member of `struct tm'. */
+#define HAVE_STRUCT_TM_TM_GMTOFF 1
+
+/* Define to 1 if you have the `syslog' function. */
+#define HAVE_SYSLOG 1
+
+/* Define to 1 if you have the <syslog.h> header file. */
+#define HAVE_SYSLOG_H 1
+
+/* Define to 1 if you have the <sys/cfgdb.h> header file. */
+/* #undef HAVE_SYS_CFGDB_H */
+
+/* Define to 1 if you have the <sys/cfgodm.h> header file. */
+/* #undef HAVE_SYS_CFGODM_H */
+
+/* Define to 1 if you have the <sys/dkstat.h> header file. */
+/* #undef HAVE_SYS_DKSTAT_H */
+
+/* Define to 1 if you have the <sys/dk.h> header file. */
+/* #undef HAVE_SYS_DK_H */
+
+/* Define to 1 if you have the <sys/filio.h> header file. */
+/* #undef HAVE_SYS_FILIO_H */
+
+/* Define to 1 if you have the <sys/ioctl.h> header file. */
+#define HAVE_SYS_IOCTL_H 1
+
+/* Define to 1 if you have the <sys/loadavg.h> header file. */
+/* #undef HAVE_SYS_LOADAVG_H */
+
+/* Define to 1 if you have the <sys/lock.h> header file. */
+/* #undef HAVE_SYS_LOCK_H */
+
+/* Define to 1 if you have the <sys/mnttab.h> header file. */
+/* #undef HAVE_SYS_MNTTAB_H */
+
+/* Define to 1 if you have the <sys/mount.h> header file. */
+#define HAVE_SYS_MOUNT_H 1
+
+/* Define to 1 if you have the <sys/mutex.h> header file. */
+/* #undef HAVE_SYS_MUTEX_H */
+
+/* Define to 1 if you have the <sys/nlist.h> header file. */
+/* #undef HAVE_SYS_NLIST_H */
+
+/* Define to 1 if you have the <sys/param.h> header file. */
+#define HAVE_SYS_PARAM_H 1
+
+/* Define to 1 if you have the <sys/procfs.h> header file. */
+#define HAVE_SYS_PROCFS_H 1
+
+/* Define to 1 if you have the <sys/proc.h> header file. */
+/* #undef HAVE_SYS_PROC_H */
+
+/* Define to 1 if you have the <sys/pstat.h> header file. */
+/* #undef HAVE_SYS_PSTAT_H */
+
+/* Define to 1 if you have the <sys/queue.h> header file. */
+#define HAVE_SYS_QUEUE_H 1
+
+/* Define to 1 if you have the <sys/resourcevar.h> header file. */
+/* #undef HAVE_SYS_RESOURCEVAR_H */
+
+/* Define to 1 if you have the <sys/resource.h> header file. */
+#define HAVE_SYS_RESOURCE_H 1
+
+/* Define to 1 if you have the <sys/socket.h> header file. */
+#define HAVE_SYS_SOCKET_H 1
+
+/* Define to 1 if you have the <sys/statfs.h> header file. */
+#define HAVE_SYS_STATFS_H 1
+
+/* Define to 1 if you have the <sys/statvfs.h> header file. */
+#define HAVE_SYS_STATVFS_H 1
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/swap.h> header file. */
+#define HAVE_SYS_SWAP_H 1
+
+/* Define to 1 if you have the <sys/sysctl.h> header file. */
+#define HAVE_SYS_SYSCTL_H 1
+
+/* Define to 1 if you have the <sys/systemcfg.h> header file. */
+/* #undef HAVE_SYS_SYSTEMCFG_H */
+
+/* Define to 1 if you have the <sys/time.h> header file. */
+#define HAVE_SYS_TIME_H 1
+
+/* Define to 1 if you have the <sys/tree.h> header file. */
+/* #undef HAVE_SYS_TREE_H */
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the <sys/ucred.h> header file. */
+/* #undef HAVE_SYS_UCRED_H */
+
+/* Define to 1 if you have the <sys/un.h> header file. */
+#define HAVE_SYS_UN_H 1
+
+/* Define to 1 if you have the <sys/user.h> header file. */
+#define HAVE_SYS_USER_H 1
+
+/* Define to 1 if you have the <sys/utsname.h> header file. */
+#define HAVE_SYS_UTSNAME_H 1
+
+/* Define to 1 if you have the <sys/vfs.h> header file. */
+#define HAVE_SYS_VFS_H 1
+
+/* Define to 1 if you have the <sys/vmmeter.h> header file. */
+/* #undef HAVE_SYS_VMMETER_H */
+
+/* Define to 1 if you have <sys/wait.h> that is POSIX.1 compatible. */
+#define HAVE_SYS_WAIT_H 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Define to 1 if you have the <uvm/uvm_extern.h> header file. */
+/* #undef HAVE_UVM_UVM_EXTERN_H */
+
+/* Define to 1 if you have the <uvm/uvm.h> header file. */
+/* #undef HAVE_UVM_UVM_H */
+
+/* Define to 1 if you have the <uvm/uvm_map.h> header file. */
+/* #undef HAVE_UVM_UVM_MAP_H */
+
+/* Define to 1 if you have the <uvm/uvm_object.h> header file. */
+/* #undef HAVE_UVM_UVM_OBJECT_H */
+
+/* Define to 1 if you have the <uvm/uvm_pmap.h> header file. */
+/* #undef HAVE_UVM_UVM_PMAP_H */
+
+/* Define to 1 if VA_COPY is defined. */
+#define HAVE_VA_COPY 1
+
+/* Define to 1 if you have the `vfork' function. */
+#define HAVE_VFORK 1
+
+/* Define to 1 if you have the <vfork.h> header file. */
+/* #undef HAVE_VFORK_H */
+
+/* Define to 1 if you have the <vm/pmap.h> header file. */
+/* #undef HAVE_VM_PMAP_H */
+
+/* Define to 1 if you have the <vm/vm.h> header file. */
+/* #undef HAVE_VM_VM_H */
+
+/* Define to 1 if you have the <vm/vm_map.h> header file. */
+/* #undef HAVE_VM_VM_MAP_H */
+
+/* Define to 1 if you have the <vm/vm_object.h> header file. */
+/* #undef HAVE_VM_VM_OBJECT_H */
+
+/* Define to 1 if you have the `vsyslog' function. */
+#define HAVE_VSYSLOG 1
+
+/* Define to 1 if `fork' works. */
+#define HAVE_WORKING_FORK 1
+
+/* Define to 1 if `vfork' works. */
+#define HAVE_WORKING_VFORK 1
+
+/* Define to 1 if `lstat' dereferences a symlink specified with a trailing
+   slash. */
+/* #undef LSTAT_FOLLOWS_SLASHED_SYMLINK */
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT "monit-general@nongnu.org"
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "monit"
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING "monit 5.2.5"
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME "monit"
+
+/* Define to the home page for this package. */
+#define PACKAGE_URL ""
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "5.2.5"
+
+/* Define to the pid storage directory. */
+#define PIDDIR "/var/run"
+
+/* Define as the return type of signal handlers (`int' or `void'). */
+#define RETSIGTYPE void
+
+/* Define to 1 if the `S_IS*' macros in <sys/stat.h> do not work properly. */
+/* #undef STAT_MACROS_BROKEN */
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
+#define TIME_WITH_SYS_TIME 1
+
+/* Define to 1 if your <sys/time.h> declares `struct tm'. */
+/* #undef TM_IN_SYS_TIME */
+
+/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most
+   significant byte first (like Motorola and SPARC, unlike Intel). */
+#if defined AC_APPLE_UNIVERSAL_BUILD
+# if defined __BIG_ENDIAN__
+#  define WORDS_BIGENDIAN 1
+# endif
+#else
+# ifndef WORDS_BIGENDIAN
+/* #  undef WORDS_BIGENDIAN */
+# endif
+#endif
+
+/* Define to 1 if `lex' declares `yytext' as a `char *' by default, not a
+   `char[]'. */
+/* #undef YYTEXT_POINTER */
+
+/* Number of bits in a file offset, on hosts where this is settable. */
+/* #undef _FILE_OFFSET_BITS */
+
+/* Define for large files, on AIX-style hosts. */
+/* #undef _LARGE_FILES */
+
+/* Define to empty if `const' does not conform to ANSI C. */
+/* #undef const */
+
+/* Define to rpl_malloc if the replacement function should be used. */
+/* #undef malloc */
+
+/* Define to `int' if <sys/types.h> does not define. */
+/* #undef mode_t */
+
+/* Define to `int' if <sys/types.h> does not define. */
+/* #undef pid_t */
+
+/* Define to `unsigned int' if <sys/types.h> does not define. */
+/* #undef size_t */
+
+/* Define to gnu_strftime if the replacement function should be used. */
+#define strftime gnu_strftime
+
+/* Define as `fork' if `vfork' does not work. */
+/* #undef vfork */
diff -rupN monit-5.2.5_orig//file.c monit-5.2.5//file.c
--- monit-5.2.5_orig//file.c	2011-03-23 11:26:53.000000000 +0100
+++ monit-5.2.5//file.c	2011-06-02 17:33:01.971378638 +0200
@@ -189,6 +189,11 @@ char *File_findControlFile() {
     return (rcfile);
   }
   memset(rcfile, 0, STRLEN);
+  snprintf(rcfile, STRLEN, "/pulsarroot/configs/monit/%s", MONITRC);
+  if(File_exist(rcfile)) {
+    return (rcfile);
+  }
+  memset(rcfile, 0, STRLEN);
   snprintf(rcfile, STRLEN, "%s/%s", SYSCONFDIR, MONITRC);
   if(File_exist(rcfile)) {
     return (rcfile);
@@ -204,8 +209,8 @@ char *File_findControlFile() {
     return (rcfile);
   }
   LogError("%s: Cannot find the control file at "
-      "~/.%s, /etc/%s, %s/%s, /usr/local/etc/%s or at ./%s \n",
-      prog, MONITRC, MONITRC, SYSCONFDIR, MONITRC, MONITRC, MONITRC);
+      "~/.%s, /etc/%s, /pulsarroot/configs/monit/%s, %s/%s, /usr/local/etc/%s or at ./%s \n",
+      prog, MONITRC, MONITRC, MONITRC, SYSCONFDIR, MONITRC, MONITRC, MONITRC);
   exit(1);
   
 }
diff -rupN monit-5.2.5_orig//getloadavg.c monit-5.2.5//getloadavg.c
--- monit-5.2.5_orig//getloadavg.c	1970-01-01 01:00:00.000000000 +0100
+++ monit-5.2.5//getloadavg.c	2011-06-02 17:23:22.142558369 +0200
@@ -0,0 +1,1077 @@
+/* Get the system load averages.
+   Copyright (C) 1985, 86, 87, 88, 89, 91, 92, 93, 1994, 1995, 1997
+   	Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+   USA.  */
+
+/* Compile-time symbols that this file uses:
+
+   HAVE_PSTAT_GETDYNAMIC	Define this if your system has the
+                                pstat_getdynamic function.  I think it
+				is unique to HPUX9.  The best way to get the
+				definition is through the AC_FUNC_GETLOADAVG
+				macro that comes with autoconf 2.13 or newer.
+				If that isn't an option, then just put
+				AC_CHECK_FUNCS(pstat_getdynamic) in your
+				configure.in file.
+   FIXUP_KERNEL_SYMBOL_ADDR()	Adjust address in returned struct nlist.
+   KERNEL_FILE			Pathname of the kernel to nlist.
+   LDAV_CVT()			Scale the load average from the kernel.
+				Returns a double.
+   LDAV_SYMBOL			Name of kernel symbol giving load average.
+   LOAD_AVE_TYPE		Type of the load average array in the kernel.
+				Must be defined unless one of
+				apollo, DGUX, NeXT, or UMAX is defined;
+				otherwise, no load average is available.
+   NLIST_STRUCT			Include nlist.h, not a.out.h, and
+				the nlist n_name element is a pointer,
+				not an array.
+   NLIST_NAME_UNION		struct nlist has an n_un member, not n_name.
+   LINUX_LDAV_FILE		[__linux__]: File containing load averages.
+
+   Specific system predefines this file uses, aside from setting
+   default values if not emacs:
+
+   apollo
+   BSD				Real BSD, not just BSD-like.
+   convex
+   DGUX
+   eunice			UNIX emulator under VMS.
+   hpux
+   __MSDOS__			No-op for MSDOS.
+   NeXT
+   sgi
+   sequent			Sequent Dynix 3.x.x (BSD)
+   _SEQUENT_			Sequent DYNIX/ptx 1.x.x (SYSV)
+   sony_news                    NEWS-OS (works at least for 4.1C)
+   UMAX
+   UMAX4_3
+   VMS
+   WINDOWS32			No-op for Windows95/NT.
+   __linux__			Linux: assumes /proc filesystem mounted.
+   				Support from Michael K. Johnson.
+   __NetBSD__			NetBSD: assumes /kern filesystem mounted.
+
+   In addition, to avoid nesting many #ifdefs, we internally set
+   LDAV_DONE to indicate that the load average has been computed.
+
+   We also #define LDAV_PRIVILEGED if a program will require
+   special installation to be able to call getloadavg.  */
+
+/* This should always be first.  */
+#include <config.h>
+
+#include <sys/types.h>
+
+/* Both the Emacs and non-Emacs sections want this.  Some
+   configuration files' definitions for the LOAD_AVE_CVT macro (like
+   sparc.h's) use macros like FSCALE, defined here.  */
+#ifdef unix
+# include <sys/param.h>
+#endif
+
+
+/* Exclude all the code except the test program at the end
+   if the system has its own `getloadavg' function.
+
+   The declaration of `errno' is needed by the test program
+   as well as the function itself, so it comes first.  */
+
+#include <errno.h>
+
+#ifndef errno
+extern int errno;
+#endif
+
+#if HAVE_LOCALE_H
+# include <locale.h>
+#endif
+#if !HAVE_SETLOCALE
+# define setlocale(Category, Locale) /* empty */
+#endif
+
+#ifndef HAVE_GETLOADAVG
+
+/* The existing Emacs configuration files define a macro called
+   LOAD_AVE_CVT, which accepts a value of type LOAD_AVE_TYPE, and
+   returns the load average multiplied by 100.  What we actually want
+   is a macro called LDAV_CVT, which returns the load average as an
+   unmultiplied double.
+
+   For backwards compatibility, we'll define LDAV_CVT in terms of
+   LOAD_AVE_CVT, but future machine config files should just define
+   LDAV_CVT directly.  */
+
+# if !defined(LDAV_CVT) && defined(LOAD_AVE_CVT)
+#  define LDAV_CVT(n) (LOAD_AVE_CVT (n) / 100.0)
+# endif
+
+# if !defined (BSD) && defined (ultrix)
+/* Ultrix behaves like BSD on Vaxen.  */
+#  define BSD
+# endif
+
+# ifdef NeXT
+/* NeXT in the 2.{0,1,2} releases defines BSD in <sys/param.h>, which
+   conflicts with the definition understood in this file, that this
+   really is BSD. */
+#  undef BSD
+
+/* NeXT defines FSCALE in <sys/param.h>.  However, we take FSCALE being
+   defined to mean that the nlist method should be used, which is not true.  */
+#  undef FSCALE
+# endif
+
+/* Set values that are different from the defaults, which are
+   set a little farther down with #ifndef.  */
+
+
+/* Some shorthands.  */
+
+# if defined (HPUX) && !defined (hpux)
+#  define hpux
+# endif
+
+# if defined (__hpux) && !defined (hpux)
+#  define hpux
+# endif
+
+# if defined (__sun) && !defined (sun)
+#  define sun
+# endif
+
+# if defined(hp300) && !defined(hpux)
+#  define MORE_BSD
+# endif
+
+# if defined(ultrix) && defined(mips)
+#  define decstation
+# endif
+
+# if defined (__SVR4) && !defined (SVR4)
+#  define SVR4
+# endif
+
+# if (defined(sun) && defined(SVR4)) || defined (SOLARIS2)
+#  define SUNOS_5
+# endif
+
+# if defined (__osf__) && (defined (__alpha) || defined (__alpha__))
+#  define OSF_ALPHA
+#  include <sys/mbuf.h>
+#  include <sys/socket.h>
+#  include <net/route.h>
+#  include <sys/table.h>
+# endif
+
+# if defined (__osf__) && (defined (mips) || defined (__mips__))
+#  define OSF_MIPS
+#  include <sys/table.h>
+# endif
+
+/* UTek's /bin/cc on the 4300 has no architecture specific cpp define by
+   default, but _MACH_IND_SYS_TYPES is defined in <sys/types.h>.  Combine
+   that with a couple of other things and we'll have a unique match.  */
+# if !defined (tek4300) && defined (unix) && defined (m68k) && defined (mc68000) && defined (mc68020) && defined (_MACH_IND_SYS_TYPES)
+#  define tek4300			/* Define by emacs, but not by other users.  */
+# endif
+
+
+/* VAX C can't handle multi-line #ifs, or lines longer than 256 chars.  */
+# ifndef LOAD_AVE_TYPE
+
+#  ifdef MORE_BSD
+#   define LOAD_AVE_TYPE long
+#  endif
+
+#  ifdef sun
+#   define LOAD_AVE_TYPE long
+#  endif
+
+#  ifdef decstation
+#   define LOAD_AVE_TYPE long
+#  endif
+
+#  ifdef _SEQUENT_
+#   define LOAD_AVE_TYPE long
+#  endif
+
+#  ifdef sgi
+#   define LOAD_AVE_TYPE long
+#  endif
+
+#  ifdef SVR4
+#   define LOAD_AVE_TYPE long
+#  endif
+
+#  ifdef sony_news
+#   define LOAD_AVE_TYPE long
+#  endif
+
+#  ifdef sequent
+#   define LOAD_AVE_TYPE long
+#  endif
+
+#  ifdef OSF_ALPHA
+#   define LOAD_AVE_TYPE long
+#  endif
+
+#  if defined (ardent) && defined (titan)
+#   define LOAD_AVE_TYPE long
+#  endif
+
+#  ifdef tek4300
+#   define LOAD_AVE_TYPE long
+#  endif
+
+#  if defined(alliant) && defined(i860) /* Alliant FX/2800 */
+#   define LOAD_AVE_TYPE long
+#  endif
+
+#  ifdef _AIX
+#   define LOAD_AVE_TYPE long
+#  endif
+
+#  ifdef convex
+#   define LOAD_AVE_TYPE double
+#   ifndef LDAV_CVT
+#    define LDAV_CVT(n) (n)
+#   endif
+#  endif
+
+# endif /* No LOAD_AVE_TYPE.  */
+
+# ifdef OSF_ALPHA
+/* <sys/param.h> defines an incorrect value for FSCALE on Alpha OSF/1,
+   according to ghazi@noc.rutgers.edu.  */
+#  undef FSCALE
+#  define FSCALE 1024.0
+# endif
+
+# if defined(alliant) && defined(i860) /* Alliant FX/2800 */
+/* <sys/param.h> defines an incorrect value for FSCALE on an
+   Alliant FX/2800 Concentrix 2.2, according to ghazi@noc.rutgers.edu.  */
+#  undef FSCALE
+#  define FSCALE 100.0
+# endif
+
+
+# ifndef	FSCALE
+
+/* SunOS and some others define FSCALE in sys/param.h.  */
+
+#  ifdef MORE_BSD
+#   define FSCALE 2048.0
+#  endif
+
+#  if defined(MIPS) || defined(SVR4) || defined(decstation)
+#   define FSCALE 256
+#  endif
+
+#  if defined (sgi) || defined (sequent)
+/* Sometimes both MIPS and sgi are defined, so FSCALE was just defined
+   above under #ifdef MIPS.  But we want the sgi value.  */
+#   undef FSCALE
+#   define FSCALE 1000.0
+#  endif
+
+#  if defined (ardent) && defined (titan)
+#   define FSCALE 65536.0
+#  endif
+
+#  ifdef tek4300
+#   define FSCALE 100.0
+#  endif
+
+#  ifdef _AIX
+#   define FSCALE 65536.0
+#  endif
+
+# endif	/* Not FSCALE.  */
+
+# if !defined (LDAV_CVT) && defined (FSCALE)
+#  define LDAV_CVT(n) (((double) (n)) / FSCALE)
+# endif
+
+/* VAX C can't handle multi-line #ifs, or lines longer that 256 characters.  */
+# ifndef NLIST_STRUCT
+
+#  ifdef MORE_BSD
+#   define NLIST_STRUCT
+#  endif
+
+#  ifdef sun
+#   define NLIST_STRUCT
+#  endif
+
+#  ifdef decstation
+#   define NLIST_STRUCT
+#  endif
+
+#  ifdef hpux
+#   define NLIST_STRUCT
+#  endif
+
+#  if defined (_SEQUENT_) || defined (sequent)
+#   define NLIST_STRUCT
+#  endif
+
+#  ifdef sgi
+#   define NLIST_STRUCT
+#  endif
+
+#  ifdef SVR4
+#   define NLIST_STRUCT
+#  endif
+
+#  ifdef sony_news
+#   define NLIST_STRUCT
+#  endif
+
+#  ifdef OSF_ALPHA
+#   define NLIST_STRUCT
+#  endif
+
+#  if defined (ardent) && defined (titan)
+#   define NLIST_STRUCT
+#  endif
+
+#  ifdef tek4300
+#   define NLIST_STRUCT
+#  endif
+
+#  ifdef butterfly
+#   define NLIST_STRUCT
+#  endif
+
+#  if defined(alliant) && defined(i860) /* Alliant FX/2800 */
+#   define NLIST_STRUCT
+#  endif
+
+#  ifdef _AIX
+#   define NLIST_STRUCT
+#  endif
+
+# endif /* defined (NLIST_STRUCT) */
+
+
+# if defined(sgi) || (defined(mips) && !defined(BSD))
+#  define FIXUP_KERNEL_SYMBOL_ADDR(nl) ((nl)[0].n_value &= ~(1 << 31))
+# endif
+
+
+# if !defined (KERNEL_FILE) && defined (sequent)
+#  define KERNEL_FILE "/dynix"
+# endif
+
+# if !defined (KERNEL_FILE) && defined (hpux)
+#  define KERNEL_FILE "/hp-ux"
+# endif
+
+# if !defined(KERNEL_FILE) && (defined(_SEQUENT_) || defined(MIPS) || defined(SVR4) || defined(ISC) || defined (sgi) || (defined (ardent) && defined (titan)))
+#  define KERNEL_FILE "/unix"
+# endif
+
+
+# if !defined (LDAV_SYMBOL) && defined (alliant)
+#  define LDAV_SYMBOL "_Loadavg"
+# endif
+
+# if !defined(LDAV_SYMBOL) && ((defined(hpux) && !defined(hp9000s300)) || defined(_SEQUENT_) || defined(SVR4) || defined(ISC) || defined(sgi) || (defined (ardent) && defined (titan)) || defined (_AIX))
+#  define LDAV_SYMBOL "avenrun"
+# endif
+
+# ifdef HAVE_UNISTD_H
+#  include <unistd.h>
+# endif
+
+# include <stdio.h>
+
+/* LOAD_AVE_TYPE should only get defined if we're going to use the
+   nlist method.  */
+# if !defined(LOAD_AVE_TYPE) && (defined(BSD) || defined(LDAV_CVT) || defined(KERNEL_FILE) || defined(LDAV_SYMBOL))
+#  define LOAD_AVE_TYPE double
+# endif
+
+# ifdef LOAD_AVE_TYPE
+
+#  ifndef VMS
+#   ifndef __linux__
+#    ifndef NLIST_STRUCT
+#     include <a.out.h>
+#    else /* NLIST_STRUCT */
+#     include <nlist.h>
+#    endif /* NLIST_STRUCT */
+
+#    ifdef SUNOS_5
+#     include <fcntl.h>
+#     include <kvm.h>
+#     include <kstat.h>
+#    endif
+
+#    if defined (hpux) && defined (HAVE_PSTAT_GETDYNAMIC)
+#     include <sys/pstat.h>
+#    endif
+
+#    ifndef KERNEL_FILE
+#     define KERNEL_FILE "/vmunix"
+#    endif /* KERNEL_FILE */
+
+#    ifndef LDAV_SYMBOL
+#     define LDAV_SYMBOL "_avenrun"
+#    endif /* LDAV_SYMBOL */
+#   endif /* __linux__ */
+
+#  else /* VMS */
+
+#   ifndef eunice
+#    include <iodef.h>
+#    include <descrip.h>
+#   else /* eunice */
+#    include <vms/iodef.h>
+#   endif /* eunice */
+#  endif /* VMS */
+
+#  ifndef LDAV_CVT
+#   define LDAV_CVT(n) ((double) (n))
+#  endif /* !LDAV_CVT */
+
+# endif /* LOAD_AVE_TYPE */
+
+# if defined(__GNU__) && !defined (NeXT)
+/* Note that NeXT Openstep defines __GNU__ even though it should not.  */
+/* GNU system acts much like NeXT, for load average purposes,
+   but not exactly.  */
+#  define NeXT
+#  define host_self mach_host_self
+# endif
+
+# ifdef NeXT
+#  ifdef HAVE_MACH_MACH_H
+#   include <mach/mach.h>
+#  else
+#   include <mach.h>
+#  endif
+# endif /* NeXT */
+
+# ifdef sgi
+#  include <sys/sysmp.h>
+# endif /* sgi */
+
+# ifdef UMAX
+#  include <stdio.h>
+#  include <signal.h>
+#  include <sys/time.h>
+#  include <sys/wait.h>
+#  include <sys/syscall.h>
+
+#  ifdef UMAX_43
+#   include <machine/cpu.h>
+#   include <inq_stats/statistics.h>
+#   include <inq_stats/sysstats.h>
+#   include <inq_stats/cpustats.h>
+#   include <inq_stats/procstats.h>
+#  else /* Not UMAX_43.  */
+#   include <sys/sysdefs.h>
+#   include <sys/statistics.h>
+#   include <sys/sysstats.h>
+#   include <sys/cpudefs.h>
+#   include <sys/cpustats.h>
+#   include <sys/procstats.h>
+#  endif /* Not UMAX_43.  */
+# endif /* UMAX */
+
+# ifdef DGUX
+#  include <sys/dg_sys_info.h>
+# endif
+
+# if defined(HAVE_FCNTL_H) || defined(_POSIX_VERSION)
+#  include <fcntl.h>
+# else
+#  include <sys/file.h>
+# endif
+
+/* Avoid static vars inside a function since in HPUX they dump as pure.  */
+
+# ifdef NeXT
+static processor_set_t default_set;
+static int getloadavg_initialized;
+# endif /* NeXT */
+
+# ifdef UMAX
+static unsigned int cpus = 0;
+static unsigned int samples;
+# endif /* UMAX */
+
+# ifdef DGUX
+static struct dg_sys_info_load_info load_info;	/* what-a-mouthful! */
+# endif /* DGUX */
+
+# ifdef LOAD_AVE_TYPE
+/* File descriptor open to /dev/kmem or VMS load ave driver.  */
+static int channel;
+/* Nonzero iff channel is valid.  */
+static int getloadavg_initialized;
+/* Offset in kmem to seek to read load average, or 0 means invalid.  */
+static long offset;
+
+#  if !defined(VMS) && !defined(sgi) && !defined(__linux__)
+static struct nlist nl[2];
+#  endif /* Not VMS or sgi */
+
+#  ifdef SUNOS_5
+static kvm_t *kd;
+#  endif /* SUNOS_5 */
+
+# endif /* LOAD_AVE_TYPE */
+
+/* Put the 1 minute, 5 minute and 15 minute load averages
+   into the first NELEM elements of LOADAVG.
+   Return the number written (never more than 3, but may be less than NELEM),
+   or -1 if an error occurred.  */
+
+int
+getloadavg (loadavg, nelem)
+     double loadavg[];
+     int nelem;
+{
+  int elem = 0;			/* Return value.  */
+
+# ifdef NO_GET_LOAD_AVG
+#  define LDAV_DONE
+  /* Set errno to zero to indicate that there was no particular error;
+     this function just can't work at all on this system.  */
+  errno = 0;
+  elem = -1;
+# endif
+
+# if !defined (LDAV_DONE) && defined (HAVE_LIBKSTAT)
+/* Use libkstat because we don't have to be root.  */
+#  define LDAV_DONE
+  kstat_ctl_t *kc;
+  kstat_t *ksp;
+  kstat_named_t *kn;
+
+  kc = kstat_open ();
+  if (kc == 0)
+    return -1;
+  ksp = kstat_lookup (kc, "unix", 0, "system_misc");
+  if (ksp == 0 )
+    return -1;
+  if (kstat_read (kc, ksp, 0) == -1)
+    return -1;
+
+
+  kn = kstat_data_lookup (ksp, "avenrun_1min");
+  if (kn == 0)
+    {
+      /* Return -1 if no load average information is available.  */
+      nelem = 0;
+      elem = -1;
+    }
+
+  if (nelem >= 1)
+    loadavg[elem++] = (double) kn->value.ul/FSCALE;
+
+  if (nelem >= 2)
+    {
+      kn = kstat_data_lookup (ksp, "avenrun_5min");
+      if (kn != 0)
+	{
+	  loadavg[elem++] = (double) kn->value.ul/FSCALE;
+
+	  if (nelem >= 3)
+	    {
+	      kn = kstat_data_lookup (ksp, "avenrun_15min");
+	      if (kn != 0)
+		loadavg[elem++] = (double) kn->value.ul/FSCALE;
+	    }
+	}
+    }
+
+  kstat_close (kc);
+# endif /* HAVE_LIBKSTAT */
+
+# if !defined (LDAV_DONE) && defined (hpux) && defined (HAVE_PSTAT_GETDYNAMIC)
+/* Use pstat_getdynamic() because we don't have to be root.  */
+#  define LDAV_DONE
+#  undef LOAD_AVE_TYPE
+
+  struct pst_dynamic dyn_info;
+  if (pstat_getdynamic (&dyn_info, sizeof (dyn_info), 0, 0) < 0)
+    return -1;
+  if (nelem > 0)
+    loadavg[elem++] = dyn_info.psd_avg_1_min;
+  if (nelem > 1)
+    loadavg[elem++] = dyn_info.psd_avg_5_min;
+  if (nelem > 2)
+    loadavg[elem++] = dyn_info.psd_avg_15_min;
+
+# endif /* hpux && HAVE_PSTAT_GETDYNAMIC */
+
+# if !defined (LDAV_DONE) && defined (__linux__)
+#  define LDAV_DONE
+#  undef LOAD_AVE_TYPE
+
+#  ifndef LINUX_LDAV_FILE
+#   define LINUX_LDAV_FILE "/proc/loadavg"
+#  endif
+
+  char ldavgbuf[40];
+  double load_ave[3];
+  int fd, count;
+
+  fd = open (LINUX_LDAV_FILE, O_RDONLY);
+  if (fd == -1)
+    return -1;
+  count = read (fd, ldavgbuf, 40);
+  (void) close (fd);
+  if (count <= 0)
+    return -1;
+
+  /* The following sscanf must use the C locale.  */
+  setlocale (LC_NUMERIC, "C");
+  count = sscanf (ldavgbuf, "%lf %lf %lf",
+		  &load_ave[0], &load_ave[1], &load_ave[2]);
+  setlocale (LC_NUMERIC, "");
+  if (count < 1)
+    return -1;
+
+  for (elem = 0; elem < nelem && elem < count; elem++)
+    loadavg[elem] = load_ave[elem];
+
+  return elem;
+
+# endif /* __linux__ */
+
+# if !defined (LDAV_DONE) && defined (__NetBSD__)
+#  define LDAV_DONE
+#  undef LOAD_AVE_TYPE
+
+#  ifndef NETBSD_LDAV_FILE
+#   define NETBSD_LDAV_FILE "/kern/loadavg"
+#  endif
+
+  unsigned long int load_ave[3], scale;
+  int count;
+  FILE *fp;
+
+  fp = fopen (NETBSD_LDAV_FILE, "r");
+  if (fp == NULL)
+    return -1;
+  count = fscanf (fp, "%lu %lu %lu %lu\n",
+		  &load_ave[0], &load_ave[1], &load_ave[2],
+		  &scale);
+  (void) fclose (fp);
+  if (count != 4)
+    return -1;
+
+  for (elem = 0; elem < nelem; elem++)
+    loadavg[elem] = (double) load_ave[elem] / (double) scale;
+
+  return elem;
+
+# endif /* __NetBSD__ */
+
+# if !defined (LDAV_DONE) && defined (NeXT)
+#  define LDAV_DONE
+  /* The NeXT code was adapted from iscreen 3.2.  */
+
+  host_t host;
+  struct processor_set_basic_info info;
+  unsigned info_count;
+
+  /* We only know how to get the 1-minute average for this system,
+     so even if the caller asks for more than 1, we only return 1.  */
+
+  if (!getloadavg_initialized)
+    {
+      if (processor_set_default (host_self (), &default_set) == KERN_SUCCESS)
+	getloadavg_initialized = 1;
+    }
+
+  if (getloadavg_initialized)
+    {
+      info_count = PROCESSOR_SET_BASIC_INFO_COUNT;
+      if (processor_set_info (default_set, PROCESSOR_SET_BASIC_INFO, &host,
+			      (processor_set_info_t) &info, &info_count)
+	  != KERN_SUCCESS)
+	getloadavg_initialized = 0;
+      else
+	{
+	  if (nelem > 0)
+	    loadavg[elem++] = (double) info.load_average / LOAD_SCALE;
+	}
+    }
+
+  if (!getloadavg_initialized)
+    return -1;
+# endif /* NeXT */
+
+# if !defined (LDAV_DONE) && defined (UMAX)
+#  define LDAV_DONE
+/* UMAX 4.2, which runs on the Encore Multimax multiprocessor, does not
+   have a /dev/kmem.  Information about the workings of the running kernel
+   can be gathered with inq_stats system calls.
+   We only know how to get the 1-minute average for this system.  */
+
+  struct proc_summary proc_sum_data;
+  struct stat_descr proc_info;
+  double load;
+  register unsigned int i, j;
+
+  if (cpus == 0)
+    {
+      register unsigned int c, i;
+      struct cpu_config conf;
+      struct stat_descr desc;
+
+      desc.sd_next = 0;
+      desc.sd_subsys = SUBSYS_CPU;
+      desc.sd_type = CPUTYPE_CONFIG;
+      desc.sd_addr = (char *) &conf;
+      desc.sd_size = sizeof conf;
+
+      if (inq_stats (1, &desc))
+	return -1;
+
+      c = 0;
+      for (i = 0; i < conf.config_maxclass; ++i)
+	{
+	  struct class_stats stats;
+	  bzero ((char *) &stats, sizeof stats);
+
+	  desc.sd_type = CPUTYPE_CLASS;
+	  desc.sd_objid = i;
+	  desc.sd_addr = (char *) &stats;
+	  desc.sd_size = sizeof stats;
+
+	  if (inq_stats (1, &desc))
+	    return -1;
+
+	  c += stats.class_numcpus;
+	}
+      cpus = c;
+      samples = cpus < 2 ? 3 : (2 * cpus / 3);
+    }
+
+  proc_info.sd_next = 0;
+  proc_info.sd_subsys = SUBSYS_PROC;
+  proc_info.sd_type = PROCTYPE_SUMMARY;
+  proc_info.sd_addr = (char *) &proc_sum_data;
+  proc_info.sd_size = sizeof (struct proc_summary);
+  proc_info.sd_sizeused = 0;
+
+  if (inq_stats (1, &proc_info) != 0)
+    return -1;
+
+  load = proc_sum_data.ps_nrunnable;
+  j = 0;
+  for (i = samples - 1; i > 0; --i)
+    {
+      load += proc_sum_data.ps_nrun[j];
+      if (j++ == PS_NRUNSIZE)
+	j = 0;
+    }
+
+  if (nelem > 0)
+    loadavg[elem++] = load / samples / cpus;
+# endif /* UMAX */
+
+# if !defined (LDAV_DONE) && defined (DGUX)
+#  define LDAV_DONE
+  /* This call can return -1 for an error, but with good args
+     it's not supposed to fail.  The first argument is for no
+     apparent reason of type `long int *'.  */
+  dg_sys_info ((long int *) &load_info,
+	       DG_SYS_INFO_LOAD_INFO_TYPE,
+	       DG_SYS_INFO_LOAD_VERSION_0);
+
+  if (nelem > 0)
+    loadavg[elem++] = load_info.one_minute;
+  if (nelem > 1)
+    loadavg[elem++] = load_info.five_minute;
+  if (nelem > 2)
+    loadavg[elem++] = load_info.fifteen_minute;
+# endif /* DGUX */
+
+# if !defined (LDAV_DONE) && defined (apollo)
+#  define LDAV_DONE
+/* Apollo code from lisch@mentorg.com (Ray Lischner).
+
+   This system call is not documented.  The load average is obtained as
+   three long integers, for the load average over the past minute,
+   five minutes, and fifteen minutes.  Each value is a scaled integer,
+   with 16 bits of integer part and 16 bits of fraction part.
+
+   I'm not sure which operating system first supported this system call,
+   but I know that SR10.2 supports it.  */
+
+  extern void proc1_$get_loadav ();
+  unsigned long load_ave[3];
+
+  proc1_$get_loadav (load_ave);
+
+  if (nelem > 0)
+    loadavg[elem++] = load_ave[0] / 65536.0;
+  if (nelem > 1)
+    loadavg[elem++] = load_ave[1] / 65536.0;
+  if (nelem > 2)
+    loadavg[elem++] = load_ave[2] / 65536.0;
+# endif /* apollo */
+
+# if !defined (LDAV_DONE) && defined (OSF_MIPS)
+#  define LDAV_DONE
+
+  struct tbl_loadavg load_ave;
+  table (TBL_LOADAVG, 0, &load_ave, 1, sizeof (load_ave));
+  loadavg[elem++]
+    = (load_ave.tl_lscale == 0
+       ? load_ave.tl_avenrun.d[0]
+       : (load_ave.tl_avenrun.l[0] / (double) load_ave.tl_lscale));
+# endif	/* OSF_MIPS */
+
+# if !defined (LDAV_DONE) && (defined (__MSDOS__) || defined (WINDOWS32))
+#  define LDAV_DONE
+
+  /* A faithful emulation is going to have to be saved for a rainy day.  */
+  for ( ; elem < nelem; elem++)
+    {
+      loadavg[elem] = 0.0;
+    }
+# endif  /* __MSDOS__ || WINDOWS32 */
+
+# if !defined (LDAV_DONE) && defined (OSF_ALPHA)
+#  define LDAV_DONE
+
+  struct tbl_loadavg load_ave;
+  table (TBL_LOADAVG, 0, &load_ave, 1, sizeof (load_ave));
+  for (elem = 0; elem < nelem; elem++)
+    loadavg[elem]
+      = (load_ave.tl_lscale == 0
+       ? load_ave.tl_avenrun.d[elem]
+       : (load_ave.tl_avenrun.l[elem] / (double) load_ave.tl_lscale));
+# endif /* OSF_ALPHA */
+
+# if !defined (LDAV_DONE) && defined (VMS)
+  /* VMS specific code -- read from the Load Ave driver.  */
+
+  LOAD_AVE_TYPE load_ave[3];
+  static int getloadavg_initialized = 0;
+#  ifdef eunice
+  struct
+  {
+    int dsc$w_length;
+    char *dsc$a_pointer;
+  } descriptor;
+#  endif
+
+  /* Ensure that there is a channel open to the load ave device.  */
+  if (!getloadavg_initialized)
+    {
+      /* Attempt to open the channel.  */
+#  ifdef eunice
+      descriptor.dsc$w_length = 18;
+      descriptor.dsc$a_pointer = "$$VMS_LOAD_AVERAGE";
+#  else
+      $DESCRIPTOR (descriptor, "LAV0:");
+#  endif
+      if (sys$assign (&descriptor, &channel, 0, 0) & 1)
+	getloadavg_initialized = 1;
+    }
+
+  /* Read the load average vector.  */
+  if (getloadavg_initialized
+      && !(sys$qiow (0, channel, IO$_READVBLK, 0, 0, 0,
+		     load_ave, 12, 0, 0, 0, 0) & 1))
+    {
+      sys$dassgn (channel);
+      getloadavg_initialized = 0;
+    }
+
+  if (!getloadavg_initialized)
+    return -1;
+# endif /* VMS */
+
+# if !defined (LDAV_DONE) && defined(LOAD_AVE_TYPE) && !defined(VMS)
+
+  /* UNIX-specific code -- read the average from /dev/kmem.  */
+
+#  define LDAV_PRIVILEGED		/* This code requires special installation.  */
+
+  LOAD_AVE_TYPE load_ave[3];
+
+  /* Get the address of LDAV_SYMBOL.  */
+  if (offset == 0)
+    {
+#  ifndef sgi
+#   ifndef NLIST_STRUCT
+      strcpy (nl[0].n_name, LDAV_SYMBOL);
+      strcpy (nl[1].n_name, "");
+#   else /* NLIST_STRUCT */
+#    ifdef NLIST_NAME_UNION
+      nl[0].n_un.n_name = LDAV_SYMBOL;
+      nl[1].n_un.n_name = 0;
+#    else /* not NLIST_NAME_UNION */
+      nl[0].n_name = LDAV_SYMBOL;
+      nl[1].n_name = 0;
+#    endif /* not NLIST_NAME_UNION */
+#   endif /* NLIST_STRUCT */
+
+#   ifndef SUNOS_5
+      if (
+#    if !(defined (_AIX) && !defined (ps2))
+	  nlist (KERNEL_FILE, nl)
+#    else  /* _AIX */
+	  knlist (nl, 1, sizeof (nl[0]))
+#    endif
+	  >= 0)
+	  /* Omit "&& nl[0].n_type != 0 " -- it breaks on Sun386i.  */
+	  {
+#    ifdef FIXUP_KERNEL_SYMBOL_ADDR
+	    FIXUP_KERNEL_SYMBOL_ADDR (nl);
+#    endif
+	    offset = nl[0].n_value;
+	  }
+#   endif /* !SUNOS_5 */
+#  else  /* sgi */
+      int ldav_off;
+
+      ldav_off = sysmp (MP_KERNADDR, MPKA_AVENRUN);
+      if (ldav_off != -1)
+	offset = (long) ldav_off & 0x7fffffff;
+#  endif /* sgi */
+    }
+
+  /* Make sure we have /dev/kmem open.  */
+  if (!getloadavg_initialized)
+    {
+#  ifndef SUNOS_5
+      channel = open ("/dev/kmem", 0);
+      if(channel >= 0) {
+        /* Set the channel to close on exec, so it does not
+         * litter any child's descriptor table.  */
+#   ifdef FD_SETFD
+#    ifndef FD_CLOEXEC
+#     define FD_CLOEXEC 1
+#    endif
+        (void) fcntl (channel, F_SETFD, FD_CLOEXEC);
+#   endif
+        getloadavg_initialized = 1;
+      }
+#  else /* SUNOS_5 */
+      /* We pass 0 for the kernel, corefile, and swapfile names
+	 to use the currently running kernel.  */
+      kd = kvm_open (0, 0, 0, O_RDONLY, 0);
+      if (kd != 0)
+	{
+	  /* nlist the currently running kernel.  */
+	  kvm_nlist (kd, nl);
+	  offset = nl[0].n_value;
+	  getloadavg_initialized = 1;
+	}
+#  endif /* SUNOS_5 */
+    }
+
+  /* If we can, get the load average values.  */
+  if (offset && getloadavg_initialized)
+    {
+      /* Try to read the load.  */
+#  ifndef SUNOS_5
+      if (lseek (channel, offset, 0) == -1L
+	  || read (channel, (char *) load_ave, sizeof (load_ave))
+	  != sizeof (load_ave))
+	{
+	  close (channel);
+	  getloadavg_initialized = 0;
+	}
+#  else  /* SUNOS_5 */
+      if (kvm_read (kd, offset, (char *) load_ave, sizeof (load_ave))
+	  != sizeof (load_ave))
+        {
+          kvm_close (kd);
+          getloadavg_initialized = 0;
+	}
+#  endif /* SUNOS_5 */
+    }
+
+  if (offset == 0 || !getloadavg_initialized)
+    return -1;
+# endif /* LOAD_AVE_TYPE and not VMS */
+
+# if !defined (LDAV_DONE) && defined (LOAD_AVE_TYPE) /* Including VMS.  */
+  if (nelem > 0)
+    loadavg[elem++] = LDAV_CVT (load_ave[0]);
+  if (nelem > 1)
+    loadavg[elem++] = LDAV_CVT (load_ave[1]);
+  if (nelem > 2)
+    loadavg[elem++] = LDAV_CVT (load_ave[2]);
+
+#  define LDAV_DONE
+# endif /* !LDAV_DONE && LOAD_AVE_TYPE */
+
+# ifdef LDAV_DONE
+  return elem;
+# else
+  /* Set errno to zero to indicate that there was no particular error;
+     this function just can't work at all on this system.  */
+  errno = 0;
+  return -1;
+# endif
+}
+
+#endif /* ! HAVE_GETLOADAVG */
+
+#ifdef TEST
+void
+main (argc, argv)
+     int argc;
+     char **argv;
+{
+  int naptime = 0;
+
+  if (argc > 1)
+    naptime = atoi (argv[1]);
+
+  while (1)
+    {
+      double avg[3];
+      int loads;
+
+      errno = 0;		/* Don't be misled if it doesn't set errno.  */
+      loads = getloadavg (avg, 3);
+      if (loads == -1)
+	{
+	  perror ("Error getting load average");
+	  exit (1);
+	}
+      if (loads > 0)
+	printf ("1-minute: %f  ", avg[0]);
+      if (loads > 1)
+	printf ("5-minute: %f  ", avg[1]);
+      if (loads > 2)
+	printf ("15-minute: %f  ", avg[2]);
+      if (loads > 0)
+	putchar ('\n');
+
+      if (naptime == 0)
+	break;
+      sleep (naptime);
+    }
+
+  exit (0);
+}
+#endif /* TEST */
